"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var formatting_1 = require("./../formatting");
var textSeek_1 = require("./../textSeek");
var getSpacingBetweenNodes_1 = require("./getSpacingBetweenNodes");
var getTextForError_1 = require("./getTextForError");
var RemoveChildrenWithFormattingTextManipulator = /** @class */ (function () {
    function RemoveChildrenWithFormattingTextManipulator(opts) {
        this.opts = opts;
    }
    RemoveChildrenWithFormattingTextManipulator.prototype.getNewText = function (inputText) {
        var _a = this.opts, children = _a.children, getSiblingFormatting = _a.getSiblingFormatting;
        var parent = children[0].getParentOrThrow();
        var sourceFile = parent.getSourceFile();
        var fullText = sourceFile.getFullText();
        var newLineKind = sourceFile.global.manipulationSettings.getNewLineKind();
        var previousSibling = children[0].getPreviousSibling();
        var nextSibling = children[children.length - 1].getNextSibling();
        var removalPos = getRemovalPos();
        this.removalPos = removalPos;
        return getPrefix() + getSpacing() + getSuffix();
        function getPrefix() {
            return fullText.substring(0, removalPos);
        }
        function getSpacing() {
            return getSpacingBetweenNodes_1.getSpacingBetweenNodes({
                parent: parent,
                previousSibling: previousSibling,
                nextSibling: nextSibling,
                newLineKind: newLineKind,
                getSiblingFormatting: getSiblingFormatting
            });
        }
        function getSuffix() {
            return fullText.substring(getRemovalEnd());
        }
        function getRemovalPos() {
            if (previousSibling != null && nextSibling != null)
                return previousSibling.getEnd();
            if (parent.getPos() === children[0].getPos())
                return children[0].getNonWhitespaceStart(); // do not shift the parent
            return children[0].isFirstNodeOnLine() ? textSeek_1.getPosAfterPreviousNonBlankLine(fullText, children[0].getNonWhitespaceStart()) : children[0].getNonWhitespaceStart();
        }
        function getRemovalEnd() {
            if (previousSibling != null && nextSibling != null) {
                var nextSiblingFormatting = getSiblingFormatting(parent, nextSibling);
                if (nextSiblingFormatting === formatting_1.FormattingKind.Blankline || nextSiblingFormatting === formatting_1.FormattingKind.Newline) {
                    var nextSiblingStartLinePos = nextSibling.getStartLinePos(true);
                    if (nextSiblingStartLinePos !== children[children.length - 1].getStartLinePos(true))
                        return nextSiblingStartLinePos;
                }
                return nextSibling.getStart();
            }
            if (parent.getEnd() === children[children.length - 1].getEnd())
                return children[children.length - 1].getEnd(); // do not shift the parent
            var nextNonSpaceOrTabChar = textSeek_1.getNextMatchingPos(fullText, children[children.length - 1].getEnd(), function (char) { return char !== " " && char !== "\t"; });
            if (fullText[nextNonSpaceOrTabChar] === "\r" || fullText[nextNonSpaceOrTabChar] === "\n")
                return textSeek_1.getPosAtNextNonBlankLine(fullText, nextNonSpaceOrTabChar);
            return nextNonSpaceOrTabChar;
        }
    };
    RemoveChildrenWithFormattingTextManipulator.prototype.getTextForError = function (newText) {
        return getTextForError_1.getTextForError(newText, this.removalPos);
    };
    return RemoveChildrenWithFormattingTextManipulator;
}());
exports.RemoveChildrenWithFormattingTextManipulator = RemoveChildrenWithFormattingTextManipulator;
