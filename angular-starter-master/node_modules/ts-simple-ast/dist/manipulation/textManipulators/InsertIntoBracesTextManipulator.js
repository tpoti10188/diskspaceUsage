"use strict";
var __extends = (this && this.__extends)/* istanbul ignore next */ || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var helpers_1 = require("./../helpers");
var InsertionTextManipulator_1 = require("./InsertionTextManipulator");
var textChecks_1 = require("./../textChecks");
var utils_1 = require("./../../utils");
var InsertIntoBracesTextManipulator = /** @class */ (function (_super) {
    __extends(InsertIntoBracesTextManipulator, _super);
    function InsertIntoBracesTextManipulator(opts) {
        var _this = 
        // todo: doing this doesn't seem right, but I'd rather have all these text manipulations happening in here
        _super.call(this, {
            insertPos: helpers_1.getInsertPosFromIndex(opts.index, opts.parent, opts.children),
            newText: getNewText()
        }) || this;
        function getNewText() {
            var parent = opts.parent, index = opts.index, childCodes = opts.childCodes, separator = opts.separator, children = opts.children;
            var sourceFile = parent.getSourceFile();
            var insertPos = helpers_1.getInsertPosFromIndex(index, parent, children);
            var newLineChar = sourceFile.global.manipulationSettings.getNewLineKind();
            var newText = "";
            for (var i = 0; i < childCodes.length; i++) {
                if (i > 0) {
                    newText += separator;
                    if (opts.separatorNewlineWhen != null && opts.separatorNewlineWhen(opts.structures[i - 1], opts.structures[i]))
                        newText += newLineChar;
                }
                newText += childCodes[i];
            }
            if (index !== 0)
                newText = separator + newText;
            else if (insertPos !== 0)
                newText = newLineChar + newText;
            else if (parent.getFullWidth() > 0)
                newText = newText + separator;
            if (opts.previousBlanklineWhen != null) {
                var previousMember = children[index - 1];
                var firstStructure = opts.structures[0];
                if (previousMember != null && opts.previousBlanklineWhen(previousMember, firstStructure))
                    newText = newLineChar + newText;
            }
            var nextMember = children[index];
            if (opts.nextBlanklineWhen != null) {
                var lastStructure = opts.structures[opts.structures.length - 1];
                if (nextMember != null && opts.nextBlanklineWhen(nextMember, lastStructure)) {
                    if (!textChecks_1.isBlankLineAtPos(sourceFile, insertPos))
                        newText = newText + newLineChar;
                }
            }
            if (utils_1.TypeGuards.isSourceFile(parent) && nextMember == null && !utils_1.StringUtils.endsWith(newText, newLineChar) && !utils_1.StringUtils.endsWith(sourceFile.getFullText(), "\n"))
                newText = newText + newLineChar;
            return newText;
        }
        return _this;
    }
    return InsertIntoBracesTextManipulator;
}(InsertionTextManipulator_1.InsertionTextManipulator));
exports.InsertIntoBracesTextManipulator = InsertIntoBracesTextManipulator;
