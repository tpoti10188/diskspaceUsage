"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var utils_1 = require("./../../utils");
var StraightReplacementNodeHandler_1 = require("./StraightReplacementNodeHandler");
var NodeHandlerHelper_1 = require("./NodeHandlerHelper");
/**
 * Handler for deailing with a parent that is going to have a child replaced based on the range.
 */
var RangeParentHandler = /** @class */ (function () {
    function RangeParentHandler(compilerFactory, opts) {
        this.compilerFactory = compilerFactory;
        this.straightReplacementNodeHandler = new StraightReplacementNodeHandler_1.StraightReplacementNodeHandler(compilerFactory);
        this.helper = new NodeHandlerHelper_1.NodeHandlerHelper(compilerFactory);
        this.start = opts.start;
        this.end = opts.end;
        this.replacingLength = opts.replacingLength;
    }
    RangeParentHandler.prototype.handleNode = function (currentNode, newNode) {
        var currentNodeChildren = new utils_1.AdvancedIterator(utils_1.ArrayUtils.toIterator(currentNode.getCompilerChildren()));
        var newNodeChildren = new utils_1.AdvancedIterator(newNode.getChildrenIterator());
        // get the first child
        while (!currentNodeChildren.done && !newNodeChildren.done && newNodeChildren.peek.getStart() < this.start)
            this.helper.handleForValues(this.straightReplacementNodeHandler, currentNodeChildren.next(), newNodeChildren.next());
        // handle the new nodes
        while (!newNodeChildren.done && newNodeChildren.peek.getStart() >= this.start && newNodeChildren.peek.getEnd() <= this.end)
            newNodeChildren.next();
        // handle the nodes being replaced
        if (this.replacingLength != null) {
            var replacingEnd = this.start + this.replacingLength;
            while (!currentNodeChildren.done && currentNodeChildren.peek.getStart() < replacingEnd)
                this.helper.forgetNodeIfNecessary(currentNodeChildren.next());
        }
        // handle the rest
        while (!currentNodeChildren.done)
            this.helper.handleForValues(this.straightReplacementNodeHandler, currentNodeChildren.next(), newNodeChildren.next());
        // ensure the new children iterator is done too
        if (!newNodeChildren.done)
            throw new Error("Error replacing tree: Should not have more children left over.");
        this.compilerFactory.replaceCompilerNode(currentNode, newNode.compilerNode);
    };
    return RangeParentHandler;
}());
exports.RangeParentHandler = RangeParentHandler;
