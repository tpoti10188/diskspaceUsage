"use strict";
var __extends = (this && this.__extends)/* istanbul ignore next */ || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ts = require("typescript");
var manipulation_1 = require("./../../manipulation");
var errors = require("./../../errors");
var utils_1 = require("./../../utils");
var structureToTexts = require("./../../structureToTexts");
var callBaseFill_1 = require("./../callBaseFill");
var base_1 = require("./../base");
var namespace_1 = require("./../namespace");
var statement_1 = require("./../statement");
exports.InterfaceDeclarationBase = base_1.ChildOrderableNode(base_1.TextInsertableNode(base_1.ExtendsClauseableNode(base_1.HeritageClauseableNode(base_1.TypeParameteredNode(base_1.JSDocableNode(base_1.AmbientableNode(namespace_1.NamespaceChildableNode(base_1.ExportableNode(base_1.ModifierableNode(base_1.NamedNode(statement_1.Statement)))))))))));
var InterfaceDeclaration = /** @class */ (function (_super) {
    __extends(InterfaceDeclaration, _super);
    function InterfaceDeclaration() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Fills the node from a structure.
     * @param structure - Structure to fill.
     */
    InterfaceDeclaration.prototype.fill = function (structure) {
        callBaseFill_1.callBaseFill(exports.InterfaceDeclarationBase.prototype, this, structure);
        if (structure.callSignatures != null)
            this.addCallSignatures(structure.callSignatures);
        if (structure.constructSignatures != null)
            this.addConstructSignatures(structure.constructSignatures);
        if (structure.indexSignatures != null)
            this.addIndexSignatures(structure.indexSignatures);
        if (structure.properties != null)
            this.addProperties(structure.properties);
        if (structure.methods != null)
            this.addMethods(structure.methods);
        return this;
    };
    /**
     * Gets the base types.
     */
    InterfaceDeclaration.prototype.getBaseTypes = function () {
        return this.getType().getBaseTypes();
    };
    /**
     * Gets the base declarations.
     */
    InterfaceDeclaration.prototype.getBaseDeclarations = function () {
        return utils_1.ArrayUtils.flatten(this.getType().getBaseTypes().map(function (t) {
            var symbol = t.getSymbol();
            return symbol == null ? [] : symbol.getDeclarations();
        }));
    };
    /**
     * Add construct signature.
     * @param structure - Structure representing the construct signature.
     */
    InterfaceDeclaration.prototype.addConstructSignature = function (structure) {
        return this.addConstructSignatures([structure])[0];
    };
    /**
     * Add construct signatures.
     * @param structures - Structures representing the construct signatures.
     */
    InterfaceDeclaration.prototype.addConstructSignatures = function (structures) {
        return this.insertConstructSignatures(manipulation_1.getEndIndexFromArray(this.compilerNode.members), structures);
    };
    /**
     * Insert construct signature.
     * @param index - Index to insert at.
     * @param structure - Structure representing the construct signature.
     */
    InterfaceDeclaration.prototype.insertConstructSignature = function (index, structure) {
        return this.insertConstructSignatures(index, [structure])[0];
    };
    /**
     * Insert properties.
     * @param index - Index to insert at.
     * @param structures - Structures representing the construct signatures.
     */
    InterfaceDeclaration.prototype.insertConstructSignatures = function (index, structures) {
        var _this = this;
        var indentationText = this.getChildIndentationText();
        // create code
        var codes = structures.map(function (s) {
            // todo: pass in the StructureToText to the function below
            var writer = _this.getWriterWithChildIndentation();
            var structureToText = new structureToTexts.ConstructSignatureDeclarationStructureToText(writer);
            structureToText.writeText(s);
            return writer.toString();
        });
        return manipulation_1.insertIntoBracesOrSourceFileWithFillAndGetChildren({
            getIndexedChildren: function () { return _this.getAllMembers(); },
            sourceFile: this.getSourceFile(),
            parent: this,
            index: index,
            childCodes: codes,
            structures: structures,
            expectedKind: ts.SyntaxKind.ConstructSignature,
            fillFunction: function (node, structure) { return node.fill(structure); }
        });
    };
    /**
     * Gets the first construct signature by a find function.
     * @param findFunction - Function to find the construct signature by.
     */
    InterfaceDeclaration.prototype.getConstructSignature = function (findFunction) {
        return utils_1.ArrayUtils.find(this.getConstructSignatures(), findFunction);
    };
    /**
     * Gets the first construct signature by a find function or throws if not found.
     * @param findFunction - Function to find the construct signature by.
     */
    InterfaceDeclaration.prototype.getConstructSignatureOrThrow = function (findFunction) {
        return errors.throwIfNullOrUndefined(this.getConstructSignature(findFunction), "Expected to find a construct signature with the provided condition.");
    };
    /**
     * Gets the interface construct signatures.
     */
    InterfaceDeclaration.prototype.getConstructSignatures = function () {
        var _this = this;
        return this.compilerNode.members.filter(function (m) { return m.kind === ts.SyntaxKind.ConstructSignature; })
            .map(function (m) { return _this.getNodeFromCompilerNode(m); });
    };
    /**
     * Add call signature.
     * @param structure - Structure representing the call signature.
     */
    InterfaceDeclaration.prototype.addCallSignature = function (structure) {
        return this.addCallSignatures([structure])[0];
    };
    /**
     * Add call signatures.
     * @param structures - Structures representing the call signatures.
     */
    InterfaceDeclaration.prototype.addCallSignatures = function (structures) {
        return this.insertCallSignatures(manipulation_1.getEndIndexFromArray(this.compilerNode.members), structures);
    };
    /**
     * Insert call signature.
     * @param index - Index to insert at.
     * @param structure - Structure representing the call signature.
     */
    InterfaceDeclaration.prototype.insertCallSignature = function (index, structure) {
        return this.insertCallSignatures(index, [structure])[0];
    };
    /**
     * Insert properties.
     * @param index - Index to insert at.
     * @param structures - Structures representing the call signatures.
     */
    InterfaceDeclaration.prototype.insertCallSignatures = function (index, structures) {
        var _this = this;
        var indentationText = this.getChildIndentationText();
        // create code
        var codes = structures.map(function (s) {
            // todo: pass in the StructureToText to the function below
            var writer = _this.getWriterWithChildIndentation();
            var structureToText = new structureToTexts.CallSignatureDeclarationStructureToText(writer);
            structureToText.writeText(s);
            return writer.toString();
        });
        return manipulation_1.insertIntoBracesOrSourceFileWithFillAndGetChildren({
            getIndexedChildren: function () { return _this.getAllMembers(); },
            sourceFile: this.getSourceFile(),
            parent: this,
            index: index,
            childCodes: codes,
            structures: structures,
            expectedKind: ts.SyntaxKind.CallSignature,
            fillFunction: function (node, structure) { return node.fill(structure); }
        });
    };
    /**
     * Gets the first call signature by a find function.
     * @param findFunction - Function to find the call signature by.
     */
    InterfaceDeclaration.prototype.getCallSignature = function (findFunction) {
        return utils_1.ArrayUtils.find(this.getCallSignatures(), findFunction);
    };
    /**
     * Gets the first call signature by a find function or throws if not found.
     * @param findFunction - Function to find the call signature by.
     */
    InterfaceDeclaration.prototype.getCallSignatureOrThrow = function (findFunction) {
        return errors.throwIfNullOrUndefined(this.getCallSignature(findFunction), "Expected to find a call signature with the provided condition.");
    };
    /**
     * Gets the interface call signatures.
     */
    InterfaceDeclaration.prototype.getCallSignatures = function () {
        var _this = this;
        return this.compilerNode.members.filter(function (m) { return m.kind === ts.SyntaxKind.CallSignature; })
            .map(function (m) { return _this.getNodeFromCompilerNode(m); });
    };
    /**
     * Add index signature.
     * @param structure - Structure representing the index signature.
     */
    InterfaceDeclaration.prototype.addIndexSignature = function (structure) {
        return this.addIndexSignatures([structure])[0];
    };
    /**
     * Add index signatures.
     * @param structures - Structures representing the index signatures.
     */
    InterfaceDeclaration.prototype.addIndexSignatures = function (structures) {
        return this.insertIndexSignatures(manipulation_1.getEndIndexFromArray(this.compilerNode.members), structures);
    };
    /**
     * Insert index signature.
     * @param index - Index to insert at.
     * @param structure - Structure representing the index signature.
     */
    InterfaceDeclaration.prototype.insertIndexSignature = function (index, structure) {
        return this.insertIndexSignatures(index, [structure])[0];
    };
    /**
     * Insert properties.
     * @param index - Index to insert at.
     * @param structures - Structures representing the index signatures.
     */
    InterfaceDeclaration.prototype.insertIndexSignatures = function (index, structures) {
        var _this = this;
        var indentationText = this.getChildIndentationText();
        // create code
        var codes = structures.map(function (s) {
            // todo: pass in the StructureToText to the function below
            var writer = _this.getWriterWithChildIndentation();
            var structureToText = new structureToTexts.IndexSignatureDeclarationStructureToText(writer);
            structureToText.writeText(s);
            return writer.toString();
        });
        return manipulation_1.insertIntoBracesOrSourceFileWithFillAndGetChildren({
            getIndexedChildren: function () { return _this.getAllMembers(); },
            sourceFile: this.getSourceFile(),
            parent: this,
            index: index,
            childCodes: codes,
            structures: structures,
            expectedKind: ts.SyntaxKind.IndexSignature,
            fillFunction: function (node, structure) { return node.fill(structure); }
        });
    };
    /**
     * Gets the first index signature by a find function.
     * @param findFunction - Function to find the index signature by.
     */
    InterfaceDeclaration.prototype.getIndexSignature = function (findFunction) {
        return utils_1.ArrayUtils.find(this.getIndexSignatures(), findFunction);
    };
    /**
     * Gets the first index signature by a find function or throws if not found.
     * @param findFunction - Function to find the index signature by.
     */
    InterfaceDeclaration.prototype.getIndexSignatureOrThrow = function (findFunction) {
        return errors.throwIfNullOrUndefined(this.getIndexSignature(findFunction), "Expected to find a index signature with the provided condition.");
    };
    /**
     * Gets the interface index signatures.
     */
    InterfaceDeclaration.prototype.getIndexSignatures = function () {
        var _this = this;
        return this.compilerNode.members.filter(function (m) { return m.kind === ts.SyntaxKind.IndexSignature; })
            .map(function (m) { return _this.getNodeFromCompilerNode(m); });
    };
    /**
     * Add method.
     * @param structure - Structure representing the method.
     */
    InterfaceDeclaration.prototype.addMethod = function (structure) {
        return this.addMethods([structure])[0];
    };
    /**
     * Add methods.
     * @param structures - Structures representing the methods.
     */
    InterfaceDeclaration.prototype.addMethods = function (structures) {
        return this.insertMethods(manipulation_1.getEndIndexFromArray(this.compilerNode.members), structures);
    };
    /**
     * Insert method.
     * @param index - Index to insert at.
     * @param structure - Structure representing the method.
     */
    InterfaceDeclaration.prototype.insertMethod = function (index, structure) {
        return this.insertMethods(index, [structure])[0];
    };
    /**
     * Insert methods.
     * @param index - Index to insert at.
     * @param structures - Structures representing the methods.
     */
    InterfaceDeclaration.prototype.insertMethods = function (index, structures) {
        var _this = this;
        var indentationText = this.getChildIndentationText();
        // create code
        var codes = structures.map(function (s) {
            // todo: pass in the StructureToText to the function below
            var writer = _this.getWriterWithChildIndentation();
            var structureToText = new structureToTexts.MethodSignatureStructureToText(writer);
            structureToText.writeText(s);
            return writer.toString();
        });
        // insert, fill, and get created nodes
        return manipulation_1.insertIntoBracesOrSourceFileWithFillAndGetChildren({
            getIndexedChildren: function () { return _this.getAllMembers(); },
            sourceFile: this.getSourceFile(),
            parent: this,
            index: index,
            childCodes: codes,
            structures: structures,
            expectedKind: ts.SyntaxKind.MethodSignature,
            fillFunction: function (node, structure) { return node.fill(structure); }
        });
    };
    InterfaceDeclaration.prototype.getMethod = function (nameOrFindFunction) {
        return utils_1.getNamedNodeByNameOrFindFunction(this.getMethods(), nameOrFindFunction);
    };
    InterfaceDeclaration.prototype.getMethodOrThrow = function (nameOrFindFunction) {
        return errors.throwIfNullOrUndefined(this.getMethod(nameOrFindFunction), function () { return utils_1.getNotFoundErrorMessageForNameOrFindFunction("interface method signature", nameOrFindFunction); });
    };
    /**
     * Gets the interface method signatures.
     */
    InterfaceDeclaration.prototype.getMethods = function () {
        var _this = this;
        return this.compilerNode.members.filter(function (m) { return m.kind === ts.SyntaxKind.MethodSignature; })
            .map(function (m) { return _this.getNodeFromCompilerNode(m); });
    };
    /**
     * Add property.
     * @param structure - Structure representing the property.
     */
    InterfaceDeclaration.prototype.addProperty = function (structure) {
        return this.addProperties([structure])[0];
    };
    /**
     * Add properties.
     * @param structures - Structures representing the properties.
     */
    InterfaceDeclaration.prototype.addProperties = function (structures) {
        return this.insertProperties(manipulation_1.getEndIndexFromArray(this.compilerNode.members), structures);
    };
    /**
     * Insert property.
     * @param index - Index to insert at.
     * @param structure - Structure representing the property.
     */
    InterfaceDeclaration.prototype.insertProperty = function (index, structure) {
        return this.insertProperties(index, [structure])[0];
    };
    /**
     * Insert properties.
     * @param index - Index to insert at.
     * @param structures - Structures representing the properties.
     */
    InterfaceDeclaration.prototype.insertProperties = function (index, structures) {
        var _this = this;
        var indentationText = this.getChildIndentationText();
        // create code
        var codes = structures.map(function (s) {
            // todo: pass in the StructureToText to the function below
            var writer = _this.getWriterWithChildIndentation();
            var structureToText = new structureToTexts.PropertySignatureStructureToText(writer);
            structureToText.writeText(s);
            return writer.toString();
        });
        return manipulation_1.insertIntoBracesOrSourceFileWithFillAndGetChildren({
            getIndexedChildren: function () { return _this.getAllMembers(); },
            sourceFile: this.getSourceFile(),
            parent: this,
            index: index,
            childCodes: codes,
            structures: structures,
            expectedKind: ts.SyntaxKind.PropertySignature,
            fillFunction: function (node, structure) { return node.fill(structure); }
        });
    };
    InterfaceDeclaration.prototype.getProperty = function (nameOrFindFunction) {
        return utils_1.getNamedNodeByNameOrFindFunction(this.getProperties(), nameOrFindFunction);
    };
    InterfaceDeclaration.prototype.getPropertyOrThrow = function (nameOrFindFunction) {
        return errors.throwIfNullOrUndefined(this.getProperty(nameOrFindFunction), function () { return utils_1.getNotFoundErrorMessageForNameOrFindFunction("interface property signature", nameOrFindFunction); });
    };
    /**
     * Gets the interface property signatures.
     */
    InterfaceDeclaration.prototype.getProperties = function () {
        var _this = this;
        return this.compilerNode.members.filter(function (m) { return m.kind === ts.SyntaxKind.PropertySignature; })
            .map(function (m) { return _this.getNodeFromCompilerNode(m); });
    };
    /**
     * Gets all members.
     */
    InterfaceDeclaration.prototype.getAllMembers = function () {
        var _this = this;
        return this.compilerNode.members.map(function (m) { return _this.getNodeFromCompilerNode(m); });
    };
    /**
     * Gets all the implementations of the interface.
     *
     * This is similar to "go to implementation."
     */
    InterfaceDeclaration.prototype.getImplementations = function () {
        return this.getNameNode().getImplementations();
    };
    return InterfaceDeclaration;
}(exports.InterfaceDeclarationBase));
exports.InterfaceDeclaration = InterfaceDeclaration;
