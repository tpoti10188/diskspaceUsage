"use strict";
var __extends = (this && this.__extends)/* istanbul ignore next */ || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ts = require("typescript");
var errors = require("./../../errors");
var manipulation_1 = require("./../../manipulation");
var structureToTexts_1 = require("./../../structureToTexts");
var utils_1 = require("./../../utils");
var callBaseFill_1 = require("./../callBaseFill");
var base_1 = require("./../base");
var namespace_1 = require("./../namespace");
var statement_1 = require("./../statement");
exports.EnumDeclarationBase = base_1.ChildOrderableNode(base_1.TextInsertableNode(namespace_1.NamespaceChildableNode(base_1.JSDocableNode(base_1.AmbientableNode(base_1.ExportableNode(base_1.ModifierableNode(base_1.NamedNode(statement_1.Statement))))))));
var EnumDeclaration = /** @class */ (function (_super) {
    __extends(EnumDeclaration, _super);
    function EnumDeclaration() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Fills the node from a structure.
     * @param structure - Structure to fill.
     */
    EnumDeclaration.prototype.fill = function (structure) {
        callBaseFill_1.callBaseFill(exports.EnumDeclarationBase.prototype, this, structure);
        if (structure.isConst != null)
            this.setIsConstEnum(structure.isConst);
        if (structure.members != null && structure.members.length > 0)
            this.addMembers(structure.members);
        return this;
    };
    /**
     * Adds a member to the enum.
     * @param structure - Structure of the enum.
     */
    EnumDeclaration.prototype.addMember = function (structure) {
        return this.addMembers([structure])[0];
    };
    /**
     * Adds members to the enum.
     * @param structures - Structures of the enums.
     */
    EnumDeclaration.prototype.addMembers = function (structures) {
        return this.insertMembers(this.getMembers().length, structures);
    };
    /**
     * Inserts a member to the enum.
     * @param index - Index to insert at.
     * @param structure - Structure of the enum.
     */
    EnumDeclaration.prototype.insertMember = function (index, structure) {
        return this.insertMembers(index, [structure])[0];
    };
    /**
     * Inserts members to an enum.
     * @param index - Index to insert at.
     * @param structures - Structures of the enums.
     */
    EnumDeclaration.prototype.insertMembers = function (index, structures) {
        var _this = this;
        var members = this.getMembers();
        index = manipulation_1.verifyAndGetIndex(index, members.length);
        if (structures.length === 0)
            return [];
        // create member code
        var newTexts = structures.map(function (s) {
            // todo: pass in the StructureToText to the function below
            var writer = _this.getWriterWithChildIndentation();
            var structureToText = new structureToTexts_1.EnumMemberStructureToText(writer);
            structureToText.writeText(s);
            return writer.toString();
        });
        // insert
        manipulation_1.insertIntoCommaSeparatedNodes({
            parent: this.getChildSyntaxListOrThrow(),
            currentNodes: members,
            insertIndex: index,
            newTexts: newTexts,
            useNewLines: true
        });
        // get the members
        var newMembers = this.getMembers().slice(index, index + structures.length);
        newMembers.forEach(function (m, i) { return m.fill(structures[i]); });
        return newMembers;
    };
    EnumDeclaration.prototype.getMember = function (nameOrFindFunction) {
        return utils_1.getNamedNodeByNameOrFindFunction(this.getMembers(), nameOrFindFunction);
    };
    EnumDeclaration.prototype.getMemberOrThrow = function (nameOrFindFunction) {
        return errors.throwIfNullOrUndefined(this.getMember(nameOrFindFunction), function () { return utils_1.getNotFoundErrorMessageForNameOrFindFunction("enum member", nameOrFindFunction); });
    };
    /**
     * Gets the enum's members.
     */
    EnumDeclaration.prototype.getMembers = function () {
        var _this = this;
        return this.compilerNode.members.map(function (m) { return _this.getNodeFromCompilerNode(m); });
    };
    /**
     * Toggle if it's a const enum
     */
    EnumDeclaration.prototype.setIsConstEnum = function (value) {
        return this.toggleModifier("const", value);
    };
    /**
     * Gets if it's a const enum.
     */
    EnumDeclaration.prototype.isConstEnum = function () {
        return this.getConstKeyword() != null;
    };
    /**
     * Gets the const enum keyword or undefined if not exists.
     */
    EnumDeclaration.prototype.getConstKeyword = function () {
        return this.getFirstModifierByKind(ts.SyntaxKind.ConstKeyword);
    };
    return EnumDeclaration;
}(exports.EnumDeclarationBase));
exports.EnumDeclaration = EnumDeclaration;
