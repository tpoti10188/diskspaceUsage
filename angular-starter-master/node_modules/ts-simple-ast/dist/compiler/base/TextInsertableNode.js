"use strict";
var __extends = (this && this.__extends)/* istanbul ignore next */ || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var errors = require("./../../errors");
var manipulation_1 = require("./../../manipulation");
var utils_1 = require("./../../utils");
function TextInsertableNode(Base) {
    return /** @class */ (function (_super) {
        __extends(class_1, _super);
        function class_1() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        class_1.prototype.insertText = function (pos, textOrWriterFunction) {
            this.replaceText([pos, pos], textOrWriterFunction);
            return this;
        };
        class_1.prototype.removeText = function (pos, end) {
            this.replaceText([pos, end], "");
            return this;
        };
        class_1.prototype.replaceText = function (range, textOrWriterFunction) {
            var thisNode = this;
            var childSyntaxList = this.getChildSyntaxListOrThrow();
            var pos = range[0];
            var end = range[1];
            verifyArguments();
            // ideally this wouldn't replace the existing syntax list
            manipulation_1.insertIntoParent({
                insertPos: pos,
                childIndex: childSyntaxList.getChildIndex(),
                insertItemsCount: 1,
                newText: utils_1.getTextFromStringOrWriter(this.global.manipulationSettings, textOrWriterFunction),
                parent: this,
                replacing: {
                    textLength: end - pos,
                    nodes: [childSyntaxList]
                }
            });
            return this;
            function verifyArguments() {
                verifyInRange(pos);
                verifyInRange(end);
                if (pos > end)
                    throw new errors.ArgumentError("range", "Cannot specify a start position greater than the end position.");
            }
            function verifyInRange(i) {
                var nodeToVerifyRange = getNodeToVerifyRange();
                if (i >= nodeToVerifyRange.getPos() && i <= nodeToVerifyRange.getEnd())
                    return;
                throw new errors.InvalidOperationError("Cannot insert or replace text outside the bounds of the node. " +
                    ("Expected a position between [" + nodeToVerifyRange.getPos() + ", " + nodeToVerifyRange.getEnd() + "], but received " + i + "."));
            }
            function getNodeToVerifyRange() {
                if (utils_1.TypeGuards.isSourceFile(thisNode))
                    return thisNode;
                return childSyntaxList;
            }
        };
        return class_1;
    }(Base));
}
exports.TextInsertableNode = TextInsertableNode;
