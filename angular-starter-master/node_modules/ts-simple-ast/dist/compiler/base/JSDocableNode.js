"use strict";
var __extends = (this && this.__extends)/* istanbul ignore next */ || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __values = (this && this.__values)/* istanbul ignore next */ || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
Object.defineProperty(exports, "__esModule", { value: true });
var manipulation_1 = require("./../../manipulation");
var structureToTexts_1 = require("./../../structureToTexts");
var callBaseFill_1 = require("./../callBaseFill");
var utils_1 = require("./../../utils");
function JSDocableNode(Base) {
    return /** @class */ (function (_super) {
        __extends(class_1, _super);
        function class_1() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        class_1.prototype.getJsDocs = function () {
            var _this = this;
            var nodes = this.compilerNode.jsDoc;
            if (nodes == null)
                return [];
            return nodes.map(function (n) { return _this.getNodeFromCompilerNode(n); });
        };
        class_1.prototype.addJsDoc = function (structure) {
            return this.addJsDocs([structure])[0];
        };
        class_1.prototype.addJsDocs = function (structures) {
            return this.insertJsDocs(manipulation_1.getEndIndexFromArray(this.compilerNode.jsDoc), structures);
        };
        class_1.prototype.insertJsDoc = function (index, structure) {
            return this.insertJsDocs(index, [structure])[0];
        };
        class_1.prototype.insertJsDocs = function (index, structures) {
            if (utils_1.ArrayUtils.isNullOrEmpty(structures))
                return [];
            var writer = this.getWriterWithIndentation();
            var structureToText = new structureToTexts_1.JSDocStructureToText(writer);
            structureToText.writeDocs(structures);
            var code = writer.toString().replace(/^\s+/, "") + this.getIndentationText();
            var nodes = this.getJsDocs();
            index = manipulation_1.verifyAndGetIndex(index, nodes.length);
            var insertPos = index === nodes.length ? this.getStart() : nodes[index].getStart();
            manipulation_1.insertIntoParentTextRange({
                insertPos: insertPos,
                parent: this,
                newText: code
            });
            return this.getJsDocs().slice(index, index + structures.length);
        };
        class_1.prototype.fill = function (structure) {
            callBaseFill_1.callBaseFill(Base.prototype, this, structure);
            if (structure.docs != null && structure.docs.length > 0)
                this.addJsDocs(structure.docs);
            return this;
        };
        return class_1;
    }(Base));
}
exports.JSDocableNode = JSDocableNode;
function getDocumentationCode(structures, indentationText, newLineText) {
    var code = "";
    try {
        for (var structures_1 = __values(structures), structures_1_1 = structures_1.next(); !structures_1_1.done; structures_1_1 = structures_1.next()) {
            var structure = structures_1_1.value;
            if (code.length > 0)
                code += "" + newLineText + indentationText;
            code += getDocumentationCodeForStructure(structure, indentationText, newLineText);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (structures_1_1 && !structures_1_1.done && (_a = structures_1.return)) _a.call(structures_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return code;
    var e_1, _a;
}
function getDocumentationCodeForStructure(structure, indentationText, newLineText) {
    var lines = structure.description.split(/\r?\n/);
    return "/**" + newLineText + lines.map(function (l) { return indentationText + " * " + l; }).join(newLineText) + ("" + newLineText + indentationText + " */");
}
