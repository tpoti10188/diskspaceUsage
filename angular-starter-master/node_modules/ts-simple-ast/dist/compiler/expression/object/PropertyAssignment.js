"use strict";
var __extends = (this && this.__extends)/* istanbul ignore next */ || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ts = require("typescript");
var manipulation_1 = require("./../../../manipulation");
var base_1 = require("./../../base");
var common_1 = require("./../../common");
// This node only has a question token in order to tell the user about bad code.
// (See https://github.com/Microsoft/TypeScript/pull/5121/files)
exports.PropertyAssignmentBase = base_1.InitializerGetExpressionableNode(base_1.QuestionTokenableNode(base_1.PropertyNamedNode(common_1.Node)));
var PropertyAssignment = /** @class */ (function (_super) {
    __extends(PropertyAssignment, _super);
    function PropertyAssignment() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Removes the initailizer and returns the new shorthand property assignment.
     *
     * Note: The current node will no longer be valid because it's no longer a property assignment.
     */
    PropertyAssignment.prototype.removeInitializer = function () {
        var initializer = this.getInitializerOrThrow();
        var colonToken = initializer.getPreviousSiblingIfKindOrThrow(ts.SyntaxKind.ColonToken);
        var childIndex = this.getChildIndex();
        var sourceFileText = this.sourceFile.getFullText();
        var insertPos = this.getStart();
        var newText = sourceFileText.substring(insertPos, colonToken.getPos()) + sourceFileText.substring(initializer.getEnd(), this.getEnd());
        var parent = this.getParentSyntaxList() || this.getParentOrThrow();
        manipulation_1.insertIntoParent({
            childIndex: childIndex,
            insertPos: insertPos,
            newText: newText,
            parent: parent,
            insertItemsCount: 1,
            replacing: {
                nodes: [this],
                textLength: this.getWidth()
            }
        });
        return parent.getChildAtIndexIfKindOrThrow(childIndex, ts.SyntaxKind.ShorthandPropertyAssignment);
    };
    /**
     * Sets the initializer.
     * @param text - New text to set for the initializer.
     */
    PropertyAssignment.prototype.setInitializer = function (text) {
        var initializer = this.getInitializerOrThrow();
        manipulation_1.insertIntoParent({
            childIndex: initializer.getChildIndex(),
            insertPos: initializer.getStart(),
            newText: text,
            parent: this,
            insertItemsCount: 1,
            replacing: {
                nodes: [initializer],
                textLength: initializer.getWidth()
            }
        });
        return this;
    };
    return PropertyAssignment;
}(exports.PropertyAssignmentBase));
exports.PropertyAssignment = PropertyAssignment;
